#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <pthread.h>
#include <unistd.h>
#include <netdb.h>
#include <fcntl.h>



/*

This a server program for serving requests of the HTTE protocol
This program is apart of the lectures of Rutgers Cyber Knights Computer
Hacking Club (R)

*/

#define MAXTHREADS 10
//global thread lock (mutex)
pthread_mutex_t threadDoneLock;
//list of thread status
int* threadDone;


/*
print error and end with error code 1
*/
void
failcleanly(char * msg){
	printf("%s\n", msg);
	exit(1);
}

/*
for challenge1
write user input into file /var/TEXT
requires program running with superuser permissions
no freeing of memory since it will fail
*/
char *
challenge1(char* input){
  //dynamic memory
  char * buffer = (char*)malloc(100);
  memset(buffer,0,100);
  char * fileName = (char*)malloc(10);
  // copy string and filname to memory
  strcpy(fileName,"/var/TEXT");
  strcpy(buffer, input);
  printf("Writing to: %s\n",fileName);

  //create and open file
  int fd = open(fileName,O_WRONLY|O_CREAT|O_APPEND);

  //null terminate string in buffer
  int index =0;
  while(buffer[index]!=0){
    index++;
  }
  buffer[index]='\0';

  // write string to file with descriptor fd
  int total_bytes = strlen(buffer);
  while(total_bytes!=0){
    int written =write(fd,buffer,total_bytes);
    total_bytes-=written;
  }
	write(fd,"\n ",2);


  close(fd);
  return fileName;
}
/*
for challenge 2
checks if user pssword is valid
no freeing of memory since it will fail
*/
int
challenge2(char* input){

  //count the size of user input
  unsigned short int size =0;
  while(input[size]!='\0'){
    size++;
  }
  //conversion
  short newsize = (short)size;
  if(newsize<0){
    newsize = newsize*-1;
  }
  //dynamic memory
  char *buffer =(char*)malloc(newsize);
  int * granted =(int*)malloc(sizeof(int));
  *granted = 0;
  //copy buffer
  strcpy(buffer, input);
  //check if granted
  if(*granted >0){
    return 1;
  }
  else{
    return 0;
  }

}

/*
determine if superuser "username" exists on system
*/
int
testuser(char* command,char * file){
    //run command on shell
    system(command);
    //open file to rediect answer too
    int fd = open(file,O_RDWR);
    char buffer[100];
    memset(buffer,0,100);
    //read answer from it
    read(fd,buffer,100);

    int index =0;
    while(buffer[index]!=0){
      index++;
    }
    buffer[index]='\0';
    //whoami return root
    if(strcmp(buffer,"root\n")==0){
      return 1;
    }
    else{
      return -1;
    }
}

/*
handler client requests
*/
void
handler(int skt){
  for(;;){
    //parsed requests
    char* reqlines[3];
    //receive request buffer
    char request[50000];
    memset(request,0,sizeof(request));
    int length;
    if((length=recv(skt,request,50000,0))>0){
      //tokenize
        reqlines[0] = strtok(request,"\n");
        reqlines[1] = strtok(NULL,"\n");
        reqlines[2] = strtok(NULL,"\n");
        char *msg = strtok(NULL,"\n");
        // if request is malformed ... ignore it
        if(reqlines[0]==NULL||reqlines[1]==NULL||reqlines[2]==NULL||msg==NULL){
          continue;
        }

        //verify valid request

        //check for request type
        if(strcmp(reqlines[0],"HTTE/1.0 GET")!=0){
          char * response = "503 FORBIDDEN";
          send(skt,response,strlen(response),0);

        }
        //check for request code
        if(strcmp(reqlines[1],"CODE: 4DEDS3")!=0){
          char * response = "503 FORBIDDEN";
          send(skt,response,strlen(response),0);
        }

        //user wants to do challenge 1
        else if(strcmp(reqlines[2],"STATUS: 1")==0){
          char * response = challenge1(msg);
          //char * response = "Running Challenge 1";
          send(skt,response,strlen(response),0);
        }
        //user wants to do challenge 2
        else if(strcmp(reqlines[2],"STATUS: 2")==0){
          int status = challenge2(msg);
          char * response;
          if(status ==1){
            response = "GRANTED!!!";
          }
          else{
            response = "DENIED!";
          }

          send(skt,response,strlen(response),0);
        }
        //user wants to see if they succeded
        else if(strcmp(reqlines[2],"STATUS: TESTUSER")==0){

          char * command = strtok(msg,"\t");
          char * file = strtok(NULL,"\t");

          int status = testuser(command,file);
          char * response;
          if(status == 1){
            response = "success user is root!";
          }
          else if(status == -1){
            response = "user is not root";
          }
          send(skt,response,strlen(response),0);
        }
        //bad request
        else{
          char * response = "503 FORBIDDEN";
          send(skt,response,strlen(response),0);
        }
    }
    else if(length ==0){
      return;
    }
  }

}


/*
Thread main loop
*/
void *
receiver(int * args){
    pthread_mutex_lock(&threadDoneLock);
    threadDone[args[1]] = 1;
    pthread_mutex_unlock(&threadDoneLock);
     handler(args[0]);
    pthread_mutex_lock(&threadDoneLock);
    threadDone[args[1]] = 0;
    pthread_mutex_unlock(&threadDoneLock);
    close(args[0]);
    free(args);
return NULL;
}

/*
free socket list
*/
void
cleanup(void){
  free(threadDone);
}


int
main(void){
  //all threads
  pthread_t threads[MAXTHREADS];
  //set up socket connection
  struct addrinfo hints;
  struct addrinfo *server_info;

  memset(&hints,0,sizeof(hints));
  hints.ai_family =AF_INET;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_protocol = 0;
  hints.ai_flags = AI_PASSIVE;
  char* port = "4000";

  //set up server info
  if(getaddrinfo(NULL,port,&hints,&server_info) != 0){
    failcleanly("gettaddrinfo() error");
  }

  //create server socket
  int server_socket;
  if((server_socket = socket(server_info->ai_family,server_info->ai_socktype,server_info->ai_protocol))==-1){
    failcleanly("socket() error");
  }

  //set socket reuse
  int reuseaddr =1;
	if(setsockopt(server_socket,SOL_SOCKET,SO_REUSEADDR,&reuseaddr,sizeof(reuseaddr))==-1){
		failcleanly("setsockopt() error");
	}

 //bind listener
	if(bind(server_socket,server_info->ai_addr,server_info->ai_addrlen)==-1){
    freeaddrinfo(server_info);
    failcleanly("bind() error");
	}
	freeaddrinfo(server_info);

  //create socket listener
  int lfd;
  if((lfd = listen(server_socket,10))==-1){
    failcleanly("listen() error");
  }

  //create mutex
  if(pthread_mutex_init(&threadDoneLock,NULL)!=0){
    failcleanly("pthread_mutex_init() error");
  }


 threadDone = (int*)malloc(sizeof(int)*10);

 int l =0;
  for(;l<MAXTHREADS;l++){
    threadDone[l] = -1;
  }


  atexit(cleanup);

  //main loop
  for(;;){
    //accept connections
    int acpt = accept(server_socket, 0,0);
    //if connection setup failed
    if(acpt == -1){
      continue;
    }
    //put in waiting connections queue
    else{
     while(1){
     	pthread_mutex_lock(&threadDoneLock);
     	int e = 0;
     	for(;e<MAXTHREADS;e++){
        	if(threadDone[e] == 0 || threadDone[e]==-1){
		int* arg= (int*)malloc(2*sizeof(int));
		arg[0]=acpt;
		arg[1]=e;
	  	 pthread_create(&threads[e],NULL,(void*(*)(void*))receiver,(void*)arg);
        		break;
		}
     	}
     	pthread_mutex_unlock(&threadDoneLock);
	if(e != MAXTHREADS){break;}
    }
  }
}
	return 0;

}
