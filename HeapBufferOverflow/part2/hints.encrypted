
Overflows to other memory segments:

[Double Decrypted AES-GCM 256+OTP file. verified by NTRUencrypt post-quantum signature scheme ]:


	You are winners of the "Hack the Pentagon" challenge and as a reward
have been hired by the Pentagon to stop Dr. Evil's new nefarious plans.
The Pentagon has located a hinden server that holds Evil's new plans.
However, the server is unlike any server they have ever seen. It only
understands HTTE (Hypertext Tranfer Evil (protocol)) developed by evil
labs incorporated. Luckily the pentagon was able to decrypt an HTTE
packet which was sent over SSL using Exported ciphers (weak). The Pentagon is now performing a
Man-the-middle attack on all of Evil's servers that use RSA-signed certificates. They are
using Quantum-computers running Shor's algorithm to obtain all RSA-2048 private keys. Thus you
are most likely the only person connecting to Evil's real server.They have given you a template python client which contains the
information required to make a request to the HTTE server. The code for the HTTE
server was given to you via Quantum-Key distribution using D-WAVE Q-computers.

The Pentagon has given you the following tasks because it knows you are
the best hackers in the world:
	1) [challenge 1]gain remote access to evil's server by adding your name as a
		superuser on Evil's server, so you can reak havoc and
		dismantle it.
		Hints: Linux holds all known username/hashed password
		int /etc/password. Evil's current server will
		write whatever payload you send it into /var/TEXt
		however you need to change that to write to /etc/password.
		In addition, you need to look at your /etc/password
		to know what root's entry looks like. To create a hash
		you should do the following on your vm:
		perl -e 'print crypt("yourpassword","XX")."\n"
		this is your hashed password for your new entry
		to /etc/password.

	2) [challenge 2]gain access to evil's encrypted folders which are only
		protected by a stupid password. The pentagon
		has intel that the password is not stored on the server

		Hints: challenge 2 is similiar to last week. However, evil has learned
		to sanitize your input by consantly expanding the required
		dynamic memory to hold your input, so you can never overflow.
		Did he miss something?
		In addition, the Pentagon has more intel that there if you craft
		a special type of request, given in the template file, you are
		able to verify if you succeeded in challenge 1.

There were many that have tried before you, but they have failed and have been
captured by evil. However, the Pentagon was able to retrieve what intel they
found. They were able to retrieve leaked source code from evil's server posted
below:

Challenge 1 leaked:
In addition they have found out something really odd, but REALLY REALLY IMPORTANT:
/bin/bash has a  symlink to /tmp/etc/passwd .... odd...

void
challenge1(char* input){
  //dynamic memory
  char * buffer = (char*)malloc(100);
  memset(buffer,0,100);
  char * fileName = (char*)malloc(10);
  // copy string and filname to memory
  strcpy(fileName,"/var/TEXT");
  strcpy(buffer, input);
  THE REST HAS BEEN REDACTED

Challenge 2 leaked:

unsigned short int size =0;
  while(input[size]!='\0'){
    size++;
  }
  //conversion
  short newsize = (short)size;
  if(newsize<0){
    newsize = newsize*-1;
  }
  //dynamic memory
  char *buffer =(char*)malloc(newsize);
  int * granted =(int*)malloc(sizeof(int));
  *granted = 0;
  //copy buffer
  strcpy(buffer, input);
THE REST HAS BEEN REDACTED


GOOD LUCK! AND MAY THE HEAP BE WITH YOU
